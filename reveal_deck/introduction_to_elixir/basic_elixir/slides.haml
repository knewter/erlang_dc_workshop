%section
  %h1 Introduction to Elixir
%section
  %h1 Three hours; Three Parts
  %ul
    %li.fragment Introduction to Elixir
    %li.fragment OTP with Elixir
    %li.fragment Building a Project
%section
  %h1 Introduction to Elixir
  %ul
    %li.fragment Basic Elixir
    %li.fragment Testing
    %li.fragment Slightly Less Basic Elixir
%section
  %h1 Introduction to Elixir
  %h2 Basic Elixir
  %ul
    %li.fragment Data Types
    %li.fragment Pattern Matching
    %li.fragment Functions
    %li.fragment Mix and Modules
%section
  %section
    %h1 Basic Elixir
    %h2 Data Types
    %ul
      %li.fragment Atoms
      %li.fragment Numbers
      %li.fragment Strings
      %li.fragment Lists
      %li.fragment Tuples
      %li.fragment Keyword Lists
      %li.fragment Regular Expressions
      %li.fragment Booleans
  %section
    %h1 Data Types
    %h2 Atoms
    %p
      Atoms are just like symbols in Ruby.  They consist of a colon, followed
      by letters, digits, and underscores
    %pre
      %code
        :preserve
          :foo
          :bar
          :"some string"
          :certain_@symbols_are_ok_too
    %aside.notes
      :markdown
        Please forgive the syntax highlighting on this slide, the funky atoms are basically exactly the sort of thing my in-browser highlighter has trouble with.

        In Elixir and Erlang, atoms are used frequently to tag response types.  You'll
        often see them as the first element in a tuple, used as a response type.  We'll
        see tuples a little later.
  %section
    %h1 Data Types
    %h2 Strings
    %pre
      %code
        :preserve
          "foo" <> "bar" #=> foobar
    %aside.notes
      :markdown
        Strings in Elixir are Erlang binaries.  They are surrounded by double quotes.
        Here I'm just showing basic string concatenation, to give you a feel for what
        that looks like.
  %section
    %h1 Data Types
    %h2 Numbers - Integers
    %pre.fragment
      %code
        :preserve
          1234567
          1_234_567
          1_234_567 == 1234567 # You can use underscores to make numbers easier to read
          12 + 24 # 36
          19 - 100 # -81
    %aside.notes
      :markdown
        Integers can be written in various ways.  Let's see a few: [advance]

        In Elixir, there's no limit on how large an integer can be.  You can do normal sorts of things with these integers:[advance]
  %section
    %h1 Data Types
    %h2 Numbers - Floating Points
    %pre.fragment
      %code
        :preserve
          1.23
          350.72
          .25 #=> (SyntaxError) iex:1: syntax error before: '.'
    %aside.notes
      :markdown
        Floating point numbers have a decimal point.

        Notice that there must be a number on both sides of the decimal in order to have a valid floating point number.
  %section
    %h1 Data Types
    %h2 Lists
    %p Lists look like arrays in other languages.
    %pre.fragment
      %code
        :preserve
          [1,2,3]
          [:foo, :bar]
          [:also, [:they, :can], [:contain, :lists]]
    %p.fragment
      They're actually just implemented as linked lists.
    %p.fragment
      You can get their head (hd) and tail (tl).
    %pre.fragment
      %code
        :preserve
          a = [1, 2, 3]
          hd(a) # 1
          tl(a) # [2, 3]
    %aside.notes
      :markdown
        Lists look like arrays in other languages, although they have different
        semantics.  Writing a list is easy [advance]

        Due to the way they're implemented, the easiest thing to do with a list is to
        get its head or its tail - that is, the first element in the list, or all the
        remaining elements in a list. [advance]

        This is because they are actually just linked lists. [advance]

        There are a couple of built in functions for accessing the head and tail of a list.  `hd` and `tl`. [advance]

        If you want something more like arrays, then you want tuples. [advance]
  %section
    %h1 Data Types
    %h2 Tuples
    %p Tuples are ordered collections:
    %pre.fragment
      %code
        :preserve
          {1, 2, 3}
          {:foo, :bar}
    %aside.notes
      :markdown
        Tuples are ordered collections. [advance]

        Tuples are used very frequently in Pattern Matching and in return values from
        various functions (those two facts are not unrelated). [advance]
  %section
    %h1 Data Types
    %h2 Keyword Lists
    %p Like Hashes or Dicts
    %pre.fragment
      %code
        :preserve
          [author: "Josh Adams", title: "Basic Elixir"]
    %p.fragment
      That's just converted into an array of 2-element tuples, so that's the same as
      the following:
    %pre.fragment
      %code
        :preserve
          [{:author, "Josh Adams"}, {:title, "Basic Elixir"}]
    %aside.notes
      :markdown
        Keyword lists are like hashes or dicts. [advance]

        That's just converted into an array of 2-element tuples, so that's the same as
        the following: [advance]

        In Erlang, keyword lists don't exist as a first-level construct.  Elixir
        provides some syntactic sugar around some core Erlang types to provide
        Keyword Lists.  These serve the same purpose as hashes in Ruby.
  %section
    %h1 Data Types
    %h2 Regular Expressions
    %p Elixir has Perl Compatible Regular Expressions.
    %pre.fragment
      %code
        :preserve
          Regex.replace %r/[aeiou]/, "Beginning Elixir", "z" # "Bzgznnzng Elzxzr"
    %aside.notes
      :markdown
        If you aren't familiar with Regular Expressions, think of them as a concise way
        to write rules for pattern matching.  If you *are* familiar with Regexes, Elixir
        has Perl Compatible Regular Expressions, so you can mostly use them like you're
        used to:
  %section
    %h1 Data Types
    %h2 Booleans
    %pre
      %code
        :preserve
          false = :false
          true = :true
    %aside.notes
      :markdown
        In Elixir, everything but `false` or `nil` is truthy.  `false` and `nil` are
        both shorthands for the atoms with the same name - namely, `:false` and `:nil`.
%section
  %section
    %h1 Basic Elixir
    %h2 Pattern Matching
    %ul
      %li.fragment Match Operator
      %li.fragment Function Definitions
      %li.fragment Case Statements
  %section
    %h1 Pattern Matching
    %h2 Match Operator
    %p "Just the equals sign"
    %pre.fragment
      %code
        :preserve
          foo = 1
    .fragment
      %p Not really...
      %pre
        %code
          :preserve
            1 = foo
    .fragment
      %pre
        %code
          :preserve
            2 = foo #=> ** (MatchError) no match of right hand side value: 1
    %aside.notes
      :markdown
        The 'Match Operator' is just the equals sign.  It looks like variable assignment
        at first glance, but there's something fishy about it: [advance]

        This sets the previously-unbound variable 'foo' to the integer 1.  That's just
        assignment, right? [advance]

        Not really.  If the equals sign is an assignment operator, why was that a valid 
        expression? It turns out the match operator is really more like making an
        assertion than it is assignment - it just turns out that if you assert an unbound
        variable matches a value, Elixir will bind the variable and the assertion will
        pass. [advance]

        `foo` already had the value 1, so the match fails and the `MatchError` is
        thrown.  Since so many things depend on Pattern Matching, I'm willing to bet you
        will run into `MatchError` quite often as you're learning.  I certainly do (both
        here and when I was learning Erlang). [advance]
  %section
    %h1 Pattern Matching
    %h2 Match Operator (cont)
    %p Here's some more advanced matches
    %pre
      %code
        :preserve
          {:foo, bar} = {:foo, 3}
    %pre.fragment
      %code
        :preserve
          {_, baz} = {1, 2}
          baz #=> 2
    %aside.notes
      :markdown
        Let's try some more advanced matches, to further explore how what we're dealing
        with is something entirely different from assignment.[advance]

        What does this expression do?  Anyone care to answer?  That's right, it assigns
        bar to 3, so that the match would be successful.
        
        Underscores play an interesting role in Elixir.  They tell the compiler that you
        don't care about the value in a given position in a Pattern you're matching on.
        Sort of like a wildcard for Pattern Matching.  Here's an example: [advance]

        Imagine we knew that the value we were interested in in the data structure we
        were matching was in its second position, and we didn't care about the other
        components.  The underscore provides a clear signal to the compiler that we just
        don't care about that value. [advance]
  %section
    %h1 Pattern Matching
    %h2 Match Operator (cont)
    %pre.fragment
      %code
        :preserve
          [a, 2] = [1, 2]
          [a, 2] = [3, 2] # Here, a gets re-bound
          [^a, 2] = [4, 2] # MatchError

    %aside.notes
      :markdown
        Finally, there's one more important point in Elixir that's different than Erlang
        and confused me for a bit.  If you want to use a variable in a pattern match as
        a filter (i.e. you want a MatchError thrown if the data on the righthand side
        doesn't match the presently-bound value in a given variable) then you need to
        signal to the compiler that you don't want to re-bind the variable.  This can be
        done with the caret-symbol, or hat (^). [advance]

        In Erlang, you cannot modify a variable once it's been bound.  Elixir removes
        this restriction, and so they had to provide this facility to differentiate
        between variable binding and variables used for matches.  It's a decent
        trade-off. [advance]

  %section
    %h1 Pattern Matching
    %h2 Function Definitions
    %p Pattern matching lets you choose amont multiple definitions of a function.
    %pre.fragment
      %code
        :preserve
          print_name_egotistically = fn
            :josh -> "Your name is Josh!"
            _     -> "I don't care what your name is!"
          end
          print_name_egotistically.(:josh)
          print_name_egotistically.(:phil)

    %aside.notes
      :markdown
        Pattern matching is used to choose between multiple possible definitions of a
        function.  As an example, I'll define a silly function: [advance]

        That function has a different function definition depending on the pattern
        matching for its arguments.  This is the first intensely different sort of thing
        that we've run into in Elixir so far.  As I was a math major in college, when I
        first ran across this sort of thing in Erlang it got me really excited, as
        that's really how I often like to see a function defined. [advance]
  %section
    %h1 Pattern Matching
    %h2 Case Statements
    %p
      Case Statements can be used for control flow, and they, too, operate based on
      Pattern Matching.
    %pre.fragment
      %code
        :preserve
          case {1,2,3} do
            {4,5,6} -> "No match here"
            {1,2,3} -> "This matches"
            {_,2,3} -> "This would match, but since it's below another match it isn't hit."
          end
%section
  %section
    %h1 Basic Elixir
    %h2 Functions
    %ul
      %li.fragment Defining anonymous functions
      %li.fragment Calling anonymous functions
      %li.fragment Using functions as first class types
    %aside.notes
      :markdown
        In Elixir, functions are first class types.  This shouldn't be terribly
        surprising; it *is* a functional programming language, after all.  Let's look at: [advance x 3]
  %section
    %h1 Functions
    %h2 Defining Them
    %pre.fragment
      %code
        :preserve
          print_name = fn
            {:person, first_name, last_name} -> first_name <> " " <> last_name
          end
    %aside.notes
      :markdown
        Anonymous functions are defined with the `fn` keyword.  Let's see what that
        looks like: [advance]

        Functions take parameter lists and bodies, separated by arrows (`->`).  The
        parameter lists are used for Pattern Matching (we actually saw function
        declaration in the last episode on Pattern Matching).

        The `print_name` function above will match a tuple containing three elements,
        when the first element is the atom `:person`.  It then matches to a body that
        will concatenate the first and last names together (where by convention, we
        assume they will be in the second and third positions in the tuple).
  %section
    %h1 Functions
    %h2 Calling Them
    %p
      The syntax to call an anonymous function in Elixir is a little weird looking at
      first.  Let's see what it looks like:
    %pre.fragment
      %code
        :preserve
          print_name.({:person, "Josh", "Adams"})
          #=> "Josh Adams"
    %pre.fragment
      %code
        :preserve
          print_name.('foo')
          # ** (FunctionClauseError) no function clause matching in :erl_eval."-inside-an-interpreted-fun-"/1
    %aside.notes
      :markdown
        The syntax to call an anonymous function in Elixir is a little weird looking at
        first.  Let's see what it looks like: [advance]

        That's easy enough, although the dot makes calling them feel different from
        calling functions in modules..  What do you think happens if you try to call it
        with an argument that doesn't match any of the parameter lists? [advance]
        
        It throws a FunctionClauseError.  It's worth noting that there's currently an
        ongoing discussion regarding removing that dot to call anonymous functions. [advance]
  %section
    %h1 Functions
    %h2 Calling Them (cont)
    %pre.fragment
      %code
        :preserve
          calculate_bill = fn
            [{:item, price}, {:item, price2}] -> price + price2
            {:item, price} -> price
          end
    %pre.fragment
      %code
        :preserve
          calculate_bill.([{:item, 20}, {:item, 10}])
          calculate_bill.({:item, 35})
    %pre.fragment
      %code
        :preserve
          (fn -> "foo" end).()
          #=> "foo"
    %aside.notes
      :markdown
        Let's define an anonymous function that behaves differently depending on the
        argument provided: [advance]

        Now, this is in fact a silly way to define this function (recursion would make
        more sense, so you could accept more than 2 items), but for the purposes of
        demonstrating Pattern Matching in functions it's acceptable. [advance]

        Now you can call this function with either a single item or a list containing
        two items, and it will return the price.  It works like this: [advance]

        So that worked, but like we said, it's pretty low-utility - it can only accept
        one or two items, tops.  I was going to follow up here by defining the function
        recursively, but recursive anonymous functions in Elixir require a bit of
        finagling with the Y combinator, so I won't cover that yet. [advance]

        One more fun thing that you can do with anonymous functions is invoke them
        immediately.  For instance: [advance]

        Obviously that, too, is a pretty unlikely example, but it serves to show off
        immediate invocation, none the less. [advance]
  %section
    %h1 Functions
    %h2 Using functions as first class types
    %pre.fragment
      %code
        :preserve
          add = fn
            num -> (fn num2 -> num + num2 end)
          end
    %pre.fragment
      %code
        :preserve
          add3 = add.(3)
          add3.(5)
          # => 8

    %aside.notes
      :markdown
        Since functions are first-class in Elixir, you can pass them as arguments or
        return them from other functions.  Let's play with that. [advance]

        Here, `add` is a function that takes an argument, and returns a function that will
        add that argument to the new function's single argument.  We can use this to
        generate a function that adds 3 to its argument: [advance]
  %section
    %h1 Functions
    %h2 Using functions as first class types (cont)
    %pre.fragment
      %code
        :preserve
          greet_person = fn
            greeter, {:person, first_name, last_name} ->
              greeter.(first_name <> " " <> last_name)
          end

          polite_greeter = fn
            name -> "Hello, \#{name}, nice to meet you!"
          end

          terse_greeter = fn
            name -> "Hi \#{name}"
          end

          person = {:person, "Josh", "Adams"}

          greet_person.(polite_greeter, person)
          greet_person.(terse_greeter, person)
    %aside.notes
      :markdown
        You can also write functions that take other functions as arguments.  For
        example: [advance]
