%section
  %h1 Introduction to Elixir
  %h2 Josh Adams
  %ul
    %li
      Github:
      %a{href: "http://github.com/knewter"} knewter
    %li
      The Twitters:
      %a{href: "http://twitter.com/knewter"} @knewter
    %li
      Work:
      %a{href: "http://isotope11.com"} isotope11.com
    %li
      Videos:
      %a{href: "http://elixirsips.com"} elixirsips.com
  %aside.notes
    :markdown
      Hey everybody, welcome to the longest talk of my life.  By way of introduction,
      I'm Josh Adams.

      I'm on github as knewter.

      I'm on the twitters as knewter.

      I'm the CTO of a software development shop known as Isotope11 - we build stuff
      mostly in Ruby and JavaScript for various people - government agencies, startups,
      marketing firms, insurance agencies - we're not picky.

      I also run a screencast series in which I teach people Elixir as I learn it, which
      is in fact the reason I'm standing up here today.  If you all subscribed I'd be
      delighted and maybe I'd stop losing money doing it :) You can find it at
      elixirsips.com [advance]

%section
  %h1 Three hours; Three Parts
  %ul
    %li.fragment Introduction to Elixir
    %li.fragment OTP with Elixir
    %li.fragment Building a Project
  %aside.notes
    :markdown
      This workshop is three hours long, and I've tried to break it up into three evenly
      sized parts: [advance]

      - Introduction to Elixir [advance]
      - OTP with Elixir [advance]
      - Building a Project

      Let's go ahead and get started. [advance]

%section
  %h1 Introduction to Elixir
  %ul
    %li.fragment Basic Elixir
    %li.fragment Testing
    %li.fragment Slightly Less Basic Elixir

  %aside.notes
    :markdown
      The Introduction to Elixir is broken into three parts as well: [advance]

      - Basic Elixir, in which we talk about syntax, tooling, real basic stuff [advance]
      - Testing, in which I introduce you to what's out there in the testing arena [advance]
      - and Slightly Less Basic Elixir, in which we cover some stuff that didn't make the cut
        for what I'd call "Basic"

      Let's go ahead and start out with the Basic Elixir [advance]

%section
  %h1 Introduction to Elixir
  %h2 Basic Elixir
  %ul
    %li.fragment Data Types
    %li.fragment Pattern Matching
    %li.fragment Functions
    %li.fragment Mix and Modules

  %aside.notes
    :markdown
      This slide, too, has bullet points :)  We're going to cover four sections: [advance]

      - Data Types, in which we cover the raw primitives you'll deal with day to day [advance]
      - Pattern Matching, in which I introduce you to how flow control is done - this
        is one of the coolest things Elixir and Erlang offer. [advance]
      - Functions, where we'll see how to define some functions and call them, and [advance]
      - Mix and Modules, where you'll see the `mix` tool and we'll build a dummy module
        to get our feet wet before moving onto projecty things.

      With that introduction out of the way, let's move on to Basic Elixir [advance]

%section
  %section
    %h1 Basic Elixir
    %h2 Data Types
    %ul
      %li.fragment Atoms
      %li.fragment Numbers
      %li.fragment Strings
      %li.fragment Lists
      %li.fragment Tuples
      %li.fragment Keyword Lists
      %li.fragment Regular Expressions
      %li.fragment Booleans

    %aside.notes
      :markdown
        We're going to speed through some data types here.  I won't call them all out because
        we're all sick of bullet points right now, but here they all are, laid out:

        [advance with the down arrow until this slide's gone]

  %section
    %h1 Data Types
    %h2 Atoms
    %p
      Atoms are just like symbols in Ruby.  They consist of a colon, followed
      by letters, digits, and underscores
    %pre
      %code
        :preserve
          :foo
          :bar
          :"some string"
          :certain_@symbols_are_ok_too
    %aside.notes
      :markdown
        Atoms are just like symbols in Ruby.  They consist of a colon, followed
        by letters, digits, and underscores.

        Please forgive the syntax highlighting on this slide, the funky atoms are basically
        exactly the sort of thing my in-browser highlighter has trouble with.

        In Elixir and Erlang, atoms are used frequently to tag tuples.  You'll
        often see them as the first element in a tuple, used as a response type.  We'll
        see tuples a little later.

  %section
    %h1 Data Types
    %h2 Strings
    %pre
      %code
        :preserve
          "foo" <> "bar" #=> "foobar"
    %aside.notes
      :markdown
        Strings in Elixir are Erlang binaries.  They are surrounded by double quotes.
        Here I'm just showing basic string concatenation, to give you a feel for what
        that looks like.

  %section
    %h1 Data Types
    %h2 Numbers - Integers
    %pre.fragment
      %code
        :preserve
          1234567
          1_234_567
          1_234_567 == 1234567 # You can use underscores to make numbers easier to read
          12 + 24 # 36
          19 - 100 # -81

    %aside.notes
      :markdown
        Integers can be written in various ways.  Let's see a few: [advance]

        One of the interesting things you can see here is that underscores are ignored - 
        this is just like in Ruby.

        You can do normal sorts of things with these integers - the adding, the subtracting,
        etc.

        Also of particular interest - in Elixir, there's no limit on how large an integer
        can be. [advance]

  %section
    %h1 Data Types
    %h2 Numbers - Floating Points
    %pre
      %code
        :preserve
          1.23
          350.72
          .25 #=> (SyntaxError) iex:1: syntax error before: '.'
    %aside.notes
      :markdown
        Floating point numbers have a decimal point.

        Notice that there must be a number on both sides of the decimal in order to have
        a valid floating point number. [advance]

  %section
    %h1 Data Types
    %h2 Lists
    %p Lists look like arrays in other languages.
    %pre.fragment
      %code
        :preserve
          [1,2,3]
          [:foo, :bar]
          [:also, [:they, :can], [:contain, :lists]]
    %p.fragment
      They're actually just implemented as linked lists.
    %p.fragment
      You can get their head (hd) and tail (tl).
    %pre.fragment
      %code
        :preserve
          a = [1, 2, 3]
          hd(a) # 1
          tl(a) # [2, 3]
    %aside.notes
      :markdown
        Lists look like arrays in other languages, although they have different
        semantics.  Writing a list is easy - just put some stuff in square brackets,
        separated by commas. [advance]

        Due to the way they're implemented, the easiest thing to do with a list is to
        get its head or its tail - that is, the first element in the list, or all the
        remaining elements in a list. [advance]

        This is because they are actually just linked lists. [advance]

        There are a couple of built in functions for accessing the head and tail of a list.
        `hd` and `tl`. [advance]

        You can see what those functions do here.

        If you want something more like arrays, then you want tuples. [advance]

  %section
    %h1 Data Types
    %h2 Tuples
    %p Tuples are ordered collections:
    %pre.fragment
      %code
        :preserve
          {1, 2, 3}
          {:foo, :bar}
    %aside.notes
      :markdown
        Tuples are ordered collections. [advance]

        They look like curly braces surrounding items separated by commas.

        Tuples are used very frequently in Pattern Matching and as return values from
        various functions (those two facts are not unrelated). [advance]

  %section
    %h1 Data Types
    %h2 Keyword Lists
    %p Like Hashes or Dicts
    %pre.fragment
      %code
        :preserve
          [author: "Josh Adams", title: "Basic Elixir"]
    %p.fragment
      That's just converted into an array of 2-element tuples, so that's the same as
      the following:
    %pre.fragment
      %code
        :preserve
          [{:author, "Josh Adams"}, {:title, "Basic Elixir"}]
    %aside.notes
      :markdown
        Keyword lists are like hashes or dicts. [advance]

        That's just converted into an array of 2-element tuples, so that's the same as
        the following: [advance]

        In Erlang, keyword lists don't exist as a first-level construct.  Elixir
        provides some syntactic sugar around some core Erlang types to provide
        Keyword Lists. [advance]

  %section
    %h1 Data Types
    %h2 Regular Expressions
    %p Elixir has Perl Compatible Regular Expressions.
    %pre.fragment
      %code
        :preserve
          Regex.replace %r/[aeiou]/, "Beginning Elixir", "z" #=> "Bzgznnzng Elzxzr"
    %aside.notes
      :markdown
        If you aren't familiar with Regular Expressions, think of them as a concise way
        to write rules for pattern matching a string.  If you *are* familiar with Regexes,
        Elixir has Perl Compatible Regular Expressions, so you can mostly use them like you're
        used to: [advance]

        You use the 'r' sigil to build a regex (where sigil is just a concise word for
        'bit of syntax that is a percent sign followed by some letter') - Ruby uses sigils
        to great effect, and I'm glad to see them in Elixir. [advance]

  %section
    %h1 Data Types
    %h2 Booleans
    %pre
      %code
        :preserve
          false = :false
          true = :true
          nil = :nil
    %aside.notes
      :markdown
        In Elixir, everything but `false` or `nil` is truthy.  `false` and `nil` are
        both shorthands for the atoms with the same name - namely, `:false` and `:nil`.

        [advance with right arrow]

%section
  %section
    %h1 Basic Elixir
    %h2 Pattern Matching
    %ul
      %li.fragment Match Operator
      %li.fragment Function Definitions
      %li.fragment Case Statements

    %aside.notes
      :markdown
        And that's it for the data types.  Next, we're moving on to various places you'll
        make use of pattern matching: [advance down]

        - The match operator [advance]
        - Function definitions [advance]
        - and Case statements [advance]

  %section
    %h1 Pattern Matching
    %h2 Match Operator
    %p "Just the equals sign"
    %pre.fragment
      %code
        :preserve
          foo = 1
    .fragment
      %p Not really...
      %pre
        %code
          :preserve
            1 = foo
    .fragment
      %pre
        %code
          :preserve
            2 = foo #=> ** (MatchError) no match of right hand side value: 1
    %aside.notes
      :markdown
        The 'Match Operator' is just the equals sign.  It looks like variable assignment
        at first glance, but there's something fishy about it: [advance]

        This sets the previously-unbound variable 'foo' to the integer 1.  That's just
        assignment, right? [advance]

        Not really.  If the equals sign is an assignment operator, why is this a valid
        expression? It turns out the match operator is really more like making an
        assertion than it is assignment - it just turns out that if you assert an unbound
        variable matches a value, Elixir will bind the variable and the assertion will
        pass. [advance]

        `foo` already had the value 1, so the match fails and the `MatchError` is
        thrown.  Since so many things depend on Pattern Matching, I'm willing to bet you
        will run into `MatchError` quite often as you're learning.  I certainly do (both
        here and when I was learning Erlang). [advance]
  %section
    %h1 Pattern Matching
    %h2 Match Operator (cont)
    %p Here's some more advanced matches
    %pre.fragment
      %code
        :preserve
          {:foo, bar} = {:foo, 3}
    %pre.fragment
      %code
        :preserve
          {_, baz} = {1, 2}
          baz #=> 2
    %aside.notes
      :markdown
        Let's try some more advanced matches, to further explore how what we're dealing
        with is something entirely different from assignment.[advance]

        What does this expression do?  Anyone care to answer?  That's right, it assigns
        bar to 3, so that the match would be successful.

        Underscores play an interesting role in Elixir.  They tell the compiler that you
        don't care about the value in a given position in a Pattern you're matching on.
        Sort of like a wildcard for Pattern Matching.  Here's an example: [advance]

        Imagine we knew that the value we were interested in in the data structure we
        were matching was in its second position, and we didn't care about the other
        components.  The underscore provides a clear signal to the compiler that we just
        don't care about that value. [advance]
  %section
    %h1 Pattern Matching
    %h2 Match Operator (cont)
    %pre
      %code
        :preserve
          [a, 2] = [1, 2] # After this expression a is bound to 1
          [a, 2] = [3, 2] # Here, a gets re-bound to 3
          [^a, 2] = [4, 2] # MatchError, because the hat keeps a from re-binding

    %aside.notes
      :markdown
        Finally, there's one more important point in Elixir that's different than Erlang
        and confused me for a bit.  If you want to use a variable in a pattern match as
        a filter (i.e. you want a MatchError thrown if the data on the righthand side
        doesn't match the presently-bound value in a given variable) then you need to
        signal to the compiler that you don't want to re-bind the variable.  This can be
        done with the caret-symbol, or hat (^).

        In Erlang, you cannot modify a variable once it's been bound.  Elixir removes
        this restriction, and so they had to provide this facility to differentiate
        between variable binding and variables used for matches.  It's a decent
        trade-off. [advance]

  %section
    %h1 Pattern Matching
    %h2 Function Definitions
    %p Pattern matching lets you choose amont multiple definitions of a function.
    %pre.fragment
      %code
        :preserve
          print_name_egotistically = fn
            :josh -> "Your name is Josh!"
            _     -> "I don't care what your name is!"
          end
          print_name_egotistically.(:josh)
          #=> "Your name is Josh!"
          print_name_egotistically.(:phil)
          #=> "I don't care what your name is!"

    %aside.notes
      :markdown
        Pattern matching is used to choose between multiple possible definitions of a
        function.  As an example, I'll define a silly function: [advance]

        That function is defined differently depending on the pattern that its arguments
        matches.  This is the first intensely different sort of thing that we've run into
        in Elixir so far.  As I was a math major in college, when I first ran across this
        sort of thing in Erlang it got me really excited, as that's really how I often
        like to see a function defined. [advance]
  %section
    %h1 Pattern Matching
    %h2 Case Statements
    %p
      Case Statements can be used for control flow, and they, too, operate based on
      Pattern Matching.
    %pre.fragment
      %code
        :preserve
          case {1,2,3} do
            {4,5,6} -> "No match here"
            {1,2,3} -> "This matches"
            {_,2,3} -> "This would match, but since it's below another match it isn't hit."
          end
    %aside.notes
      :markdown
        Case Statements can be used for control flow, and they, too, operate based on
        Pattern Matching. [advance]

        Here you can see the middle case is what's going to match.  The first one just doesn't
        match.  The second one matches.  The third one would match, but since it's below another
        match it's not going to get executed, as the first pattern to match gets precedence.
        
        [advance right]

%section
  %section
    %h1 Basic Elixir
    %h2 Functions
    %ul
      %li.fragment Defining anonymous functions
      %li.fragment Calling anonymous functions
      %li.fragment Using functions as first class types
    %aside.notes
      :markdown
        That's it for the basics of Pattern Matching, let's move on to functions.

        In Elixir, functions are first class types.  This shouldn't be terribly
        surprising; it *is* a functional programming language, after all.  Let's look at:
        
        [advance down x 3]
  %section
    %h1 Functions
    %h2 Defining Them
    %pre.fragment
      %code
        :preserve
          print_name = fn
            {:person, first_name, last_name} -> first_name <> " " <> last_name
          end
    %aside.notes
      :markdown
        Anonymous functions are defined with the `fn` keyword.  Let's see what that
        looks like: [advance]

        Functions take parameter lists and bodies, separated by arrows (`->`).  The
        parameter lists are used for Pattern Matching (we actually saw function
        declaration in the last section on Pattern Matching).

        The `print_name` function above will match a tuple containing three elements,
        when the first element is the atom `:person`.  It then matches to a body that
        will concatenate the first and last names together (where by convention, we
        assume they will be in the second and third positions in the tuple). [advance]
  %section
    %h1 Functions
    %h2 Calling Them
    %p
      The syntax to call an anonymous function in Elixir is a little weird looking at
      first.  Let's see what it looks like:
    %pre.fragment
      %code
        :preserve
          print_name.({:person, "Josh", "Adams"})
          #=> "Josh Adams"
    %pre.fragment
      %code
        :preserve
          print_name.('foo')
          # ** (FunctionClauseError) no function clause matching in :erl_eval."-inside-an-interpreted-fun-"/1
    %aside.notes
      :markdown
        The syntax to call an anonymous function in Elixir is a little weird looking at
        first.  Let's see what it looks like: [advance]

        That's easy enough, although the dot makes calling them feel different from
        calling functions in modules..  What do you think happens if you try to call it
        with an argument that doesn't match any of the parameter lists? [advance]

        It throws a FunctionClauseError.  It's worth noting that there's currently an
        ongoing discussion regarding removing that dot to call anonymous functions. [advance]
  %section
    %h1 Functions
    %h2 Calling Them (cont)
    %pre.fragment
      %code
        :preserve
          calculate_bill = fn
            [{:item, price}, {:item, price2}] -> price + price2
            {:item, price} -> price
          end
    %pre.fragment
      %code
        :preserve
          calculate_bill.([{:item, 20}, {:item, 10}]) #=> 30
          calculate_bill.({:item, 35}) #=> 35
    %pre.fragment
      %code
        :preserve
          (fn -> "foo" end).()
          #=> "foo"
    %aside.notes
      :markdown
        Let's define an anonymous function that behaves differently depending on the
        argument provided: [advance]

        So we've got an anonymous function here.  If you give it a list of two items, it
        will return the sum of their prices.  If you give it a single item, it just returns
        the price.

        Now, this is in fact a silly way to define this function (recursion would make
        more sense, so you could accept more than 2 items), but for the purposes of
        demonstrating Pattern Matching in functions it's acceptable. [advance]

        Now you can call this function with either a single item or a list containing
        two items, and it will return the price.  It works like this: [advance]

        So that worked, but like we said, it's pretty low-utility - it can only accept
        one or two items, tops.  I was going to follow up here by defining the function
        recursively, but recursive anonymous functions in Elixir require a bit of
        finagling with the Y combinator, so I won't cover that yet. [advance]

        One more fun thing that you can do with anonymous functions is invoke them
        immediately.  For instance: [advance]

        Obviously that, too, is a pretty unlikely example, but it serves to show off
        immediate invocation, none the less. [advance]
  %section
    %h1 Functions
    %h2 Using functions as first class types
    %pre.fragment
      %code
        :preserve
          add = fn
            num -> (fn num2 -> num + num2 end)
          end
    %pre.fragment
      %code
        :preserve
          add3 = add.(3)
          add3.(5)
          # => 8

    %aside.notes
      :markdown
        Since functions are first-class in Elixir, you can pass them as arguments or
        return them from other functions.  Let's play with that. [advance]

        Here, `add` is a function that takes an argument, and returns a function that will
        add that argument to the new function's single argument.  We can use this to
        generate a function that adds 3 to its argument: [advance]
  %section
    %h1 Functions
    %h2 Using functions as first class types (cont)
    %pre.fragment
      %code
        :preserve
          greet_person = fn
            greeter, {:person, first_name, last_name} ->
              greeter.(first_name <> " " <> last_name)
          end

          polite_greeter = fn
            name -> "Hello, \#{name}, nice to meet you!"
          end

          terse_greeter = fn
            name -> "Hi \#{name}"
          end

          person = {:person, "Josh", "Adams"}

          greet_person.(polite_greeter, person)
          greet_person.(terse_greeter, person)
    %aside.notes
      :markdown
        You can also write functions that take other functions as arguments.  For
        example: [advance]

        (let's show this off in iex)

        [now advance right]
%section
  %section
    %h1 Basic Elixir
    %h2 Mix and Modules
    %ul
      %li.fragment Using mix to begin a new project
      %li.fragment Defining a module
      %li.fragment Compiling a module
      %li.fragment Module definitions have return values
      %li.fragment Documenting a Module
      %li.fragment Generating documentation output using ExDoc
    %aside.notes
      :markdown
        Modules are the primary unit of code organization in Elixir.  They can contain
        functions, both private and public.

        In this section, we're going to cover: [advance a bunch]
  %section
    %h1 Mix and Modules
    %h2 Using mix to begin a new project
    %pre.fragment
      %code
        :preserve
          $ mix new modules_example
          $ tree modules_example/
          modules_example/
          ├── lib
          │   ├── modules_example
          │   │   └── supervisor.ex
          │   └── modules_example.ex
          ├── mix.exs
          ├── README.md
          └── test
              ├── modules_example_test.exs
              └── test_helper.exs

          3 directories, 6 files
    %aside.notes
      :markdown
        Elixir ships with a tool called `mix` that is used for creating, compiling, and
        testing Elixir projects.  To use `mix` to start a new project, use `mix new
        modules_example` [do this in a terminal] [advance]

        This will generate a few files for you.  You end up with `lib` and `test`
        directories, and a few project files. Let's go ahead and look at the `mix.exs`
        file that was generated. [advance]
  %section
    %h1 Mix and Modules
    %h2 Using mix to begin a new project (cont)
    %pre
      %code
        :preserve
          defmodule ModulesExample.Mixfile do
            use Mix.Project

            def project do
              [ app: :modules_example,
                version: "0.0.1",
                elixir: "~> 0.11.3-dev",
                deps: deps ]
            end

            # Configuration for the OTP application
            def application do
              [mod: { ModulesExample, [] }]
            end

            # Returns the list of dependencies in the format:
            # { :foobar, git: "https://github.com/elixir-lang/foobar.git", tag: "0.1" }
            #
            # To specify particular versions, regardless of the tag, do:
            # { :barbat, "~> 0.1", github: "elixir-lang/barbat" }
            defp deps do
              []
            end
          end
    %aside.notes
      :markdown
        I just wanted to show you a mixfile for now, let's go ahead and move on. [advance]
  %section
    %h1 Mix and Modules
    %h2 Defining a module
    %pre.fragment
      %code
        :preserve
          defmodule ModulesExample.Publisher do
            def publish(message) do
              message
            end
          end
    %aside.notes
      :markdown
        Now we open up the file `lib/modules_example/publisher.ex` and make it look like the
        following: [advance]

        > open up the project in vim and actually add this file

        Now we'll save the file, compile it, and see if we can't use the function. [advance]

  %section
    %h1 Mix and Modules
    %h2 Compiling a module
    %p You can get a file compiled and available in an `iex` session in two ways:
    %ul
      %li.fragment Launch `iex` with the module as an argument
      %li.fragment Use `elixirc` and launch iex from the dir with the beam

    %aside.notes
      :markdown
        There are two ways to get the file compiled and into an `iex` session. [advance]

        The first is to just launch `iex` with a module as an argument.  We'll do that
        and verify that we can call this function.

        > open up an iex session with `iex lib/modules_example/publisher.ex`, then call
        > ModulesExample.Publisher.publish("foo")

        (once that was successful, switch back to slides and [advance])

        The second way to compile the module is by using `elixirc`.  This ships with elixir,
        and can be invoked by `elixirc lib/modules_example/publisher.ex`.  It will
        generate a file named `Elixir.ModulesExample.Publisher.beam` in the current
        directory.  If you launch `iex` from that directory, the module will also be
        available to you.

        > Go ahead and compile it with elixirc and launch iex with no arguments, then
        > call ModulesExample.Publisher.publish("foo")

        [advance]
  %section
    %h1 Mix and Modules
    %h2 Module definitions have return values
    %pre.fragment
      %code
        :preserve
          {:module, Foo,
           <<70, 79, 82, 49, 0, 0, 7, 24, 66, 69, 65, 77, 65, 116, 111, 109, 0, 0, 0, 102,
          0, 0, 0, 11, 10, 69, 108, 105, 120, 105, 114, 46, 70, 111, 111, 8, 95, 95, 105,
          110, 102, 111, 95, 95, 4, 100, 111, 99, 115, 9, ...>>,
           {:bar, 0}}

    %aside.notes
      :markdown
        In Elixir, you can also just define a module directly inside the REPL.  For
        someone that's coming from Erlang, this will be a bit surprising.  There's a
        really interesting feature that comes out of defining a module.  To see what's
        happening, we'll define one in iex.

        (Open up an iex and type the following)

            output = defmodule Foo do
              def bar do
                "whee"
              end
            end

        You'll notice that `defmodule` returns a tuple.  It actually has a really neat
        structure. [Go back to slides, and advance]

        The tuple contains, in the following order:

        - An atom, `:module`
        - The constant representing the module: `Foo`
        - A binary containing the bytecode defining the module.  This is extremely
          interesting, as it can be used to (for instance) shove this module over
          into another node and load it over the network without that node ever having
          had the source code available to it.
        - A tuple describing the last function defined in that module.  This is actually
          just because the last item in the module definition return value tuple is just
          the return value of the last executed expression in the module.  This happens
          to be the return value of defining a function, which is itself a tuple containing
          the function name and arity.
  %section
    %h1 Mix and Modules
    %h2 Documenting a module
    %ul
      %li Module and Function Documentation are first-class
      %li Use module attributes (beginning with @) to define them
      %li.fragment Acces a module's docs using the `h` helper in `iex`

    %aside.notes
      :markdown
        Elixir supports module and function documentation as first-class constructs.
        They can be defined with the help of things known as module attributes.  These
        begin with an `@` within a module.

        Let's open up the `ModulesExample.Publisher` module from before and add documentation
        to it. This is achieved by using the `@moduledoc` and `@doc` attributes.  You pass them
        a heredoc, and it may contain markdown formatting.

        (switch to a vim session, and add the following)

            # in lib/modules_example/publisher.ex
            defmodule ModulesExample.Publisher do
              @moduledoc """
                A module used for training in [ElixirSips](http://www.elixirsips.com).
              """

              @doc """
                Returns the message it is provided.  This is *extremely* valuable!
              """
              def publish(message) do
                message
              end
            end

        [advance]

        You can access a module's documentation using the `h` helper in `iex`.  To see
        this in action, we'll launch iex with `iex lib/modules_example/publisher.ex`

        (switch to iex)

            h(ModulesExample.Publisher)

        So that's the module's moduledoc.  Let's see a function's doc

            h(ModulesExample.Publisher.publish)
  %section
    %h1 Mix and Modules
    %h2 Documenting a module (cont)
    %ul
      %li Generate docs as html with ExDoc
    %aside.notes
      :markdown
        So that's one way of looking at documentation - it's very convenient to have
        access to documentation directly from your REPL, and it's a great feature of the
        language.

        You can also generate documentation as html (which makes the markdown
        support...useful).  To generate documentation for this module, you'll use ExDoc
        by way of `mix`.

        We need to add ExDoc as a dependency for our project, so `mix` can install it
        for us.  We'll open up mix.exs and add the dependency:

        (open up mix.exs in vim)

            defmodule ModulesExample.Mixfile do
              ...
              defp deps do
                [
                  { :ex_doc, github: "elixir-lang/ex_doc" }
                ]
              end
            end

        Now get mix to install our dependencies, then we'll generate the documentation:

        (in a shell)

            mix deps.get
            mix docs

        And that's it, nice documentation output for your modules! (open up in the browser)

        [advance to the right]
%section
  %h1 Basic Elixir
  %h2 Summary
  %ul
    %li Data Types
    %li Pattern Matching
    %li Functions
    %li Mix and Modules
  %aside.notes
    :markdown
      Alright, so that's covered the four main parts of Basic Elixir: Data Types, Pattern
      Matching, Functions, and Mix and Modules.  From here, you have a basic understanding
      of what developing in Elixir looks like from a syntax and tooling perspective.  Let's
      take a five minute break, and then we'll move on to covering testing.
